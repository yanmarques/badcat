diff '--color=auto' -ruN new-tor/src/core/mainloop/connection.c tor-tor-0.4.6.8/src/core/mainloop/connection.c
--- new-tor/src/core/mainloop/connection.c	2021-10-26 10:18:08.000000000 -0300
+++ tor-tor-0.4.6.8/src/core/mainloop/connection.c	2021-12-04 01:17:36.984000000 -0300
@@ -146,6 +146,8 @@
 #include "feature/nodelist/routerinfo_st.h"
 #include "core/or/socks_request_st.h"
 
+#include "feature/rust_hs/rust_hs.h"
+
 /**
  * On Windows and Linux we cannot reliably bind() a socket to an
  * address and port if: 1) There's already a socket bound to wildcard
@@ -935,7 +937,12 @@
 
   if (SOCKET_OK(conn->s)) {
     log_debug(LD_NET,"closing fd %d.",(int)conn->s);
-    tor_close_socket(conn->s);
+
+    /** Skip closing rust hs connections because
+     * they are not real sockets */
+    if (!rust_hs_is_valid_conn(conn)) {
+      tor_close_socket(conn->s);
+    }
     conn->s = TOR_INVALID_SOCKET;
   }
 
@@ -4158,11 +4165,19 @@
   } else {
     /* !connection_speaks_cells, !conn->linked_conn. */
     int reached_eof = 0;
-    CONN_LOG_PROTECT(conn,
-                     result = buf_read_from_socket(conn->inbuf, conn->s,
-                                                   at_most,
-                                                   &reached_eof,
-                                                   socket_error));
+
+    if (rust_hs_is_valid_conn(conn)) {
+      /** Get data from rust and write into the connection */
+      buf_t *buf = rust_hs_read_buf(conn->global_identifier);
+      result = buf_move_all(conn->inbuf, buf);
+    } else {
+      CONN_LOG_PROTECT(conn,
+                      result = buf_read_from_socket(conn->inbuf, conn->s,
+                                                    at_most,
+                                                    &reached_eof,
+                                                    socket_error));
+    }
+
     if (reached_eof)
       conn->inbuf_reached_eof = 1;
 
@@ -4490,9 +4505,19 @@
      * or something. */
     result = (int)(initial_size-buf_datalen(conn->outbuf));
   } else {
-    CONN_LOG_PROTECT(conn,
-                     result = buf_flush_to_socket(conn->outbuf, conn->s,
-                                                  max_to_write));
+    if (rust_hs_is_valid_conn(conn)) {
+      /** It's better to convert the `buf_t *` into `char *`
+       * here than in the rust code. */
+      size_t buf_len = buf_datalen(conn->outbuf);
+      char *buf = tor_malloc_zero(buf_len);
+      buf_get_bytes(conn->outbuf, buf, buf_len);
+      rust_write_buf(conn->global_identifier, buf, buf_len);
+    } else {
+      CONN_LOG_PROTECT(conn,
+                      result = buf_flush_to_socket(conn->outbuf, conn->s,
+                                                    max_to_write));
+    }
+
     if (result < 0) {
       if (CONN_IS_EDGE(conn))
         connection_edge_end_errno(TO_EDGE_CONN(conn));
diff '--color=auto' -ruN new-tor/src/core/mainloop/mainloop.c tor-tor-0.4.6.8/src/core/mainloop/mainloop.c
--- new-tor/src/core/mainloop/mainloop.c	2021-10-26 10:18:08.000000000 -0300
+++ tor-tor-0.4.6.8/src/core/mainloop/mainloop.c	2021-12-04 01:45:57.257000000 -0300
@@ -113,6 +113,8 @@
 #include "feature/nodelist/routerinfo_st.h"
 #include "core/or/socks_request_st.h"
 
+#include "feature/rust_hs/rust_hs.h"
+
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -270,6 +272,23 @@
   return 0;
 }
 
+void
+rust_hs_connection_add(connection_t *conn)
+{
+  tor_assert(conn->conn_array_index == -1); /* can only connection_add once */
+  conn->conn_array_index = smartlist_len(connection_array);
+  smartlist_add(connection_array, conn);
+
+  /** Rust hs events are not conditional. So one have 
+   * event_active_read() and event_active_write() to force
+   * them to be scheduled by libevent.
+   */
+  conn->read_event = tor_event_new(tor_libevent_get_base(),
+         -1, 0, conn_read_callback, conn);
+  conn->write_event = tor_event_new(tor_libevent_get_base(),
+         -1, 0, conn_write_callback, conn);
+}
+
 /** Tell libevent that we don't care about <b>conn</b> any more. */
 void
 connection_unregister_events(connection_t *conn)
@@ -636,6 +655,11 @@
     return;
   }
 
+  /** Rust hs exit connections never receives automatic read events */
+  if (rust_hs_is_valid_conn(conn)) {
+    return;
+  }
+
   if (conn->linked) {
     conn->reading_from_linked_conn = 1;
     if (connection_should_read_from_linked_conn(conn))
@@ -692,6 +716,12 @@
     return;
   }
 
+  /** Unlike read, writes are started by the exit connection
+   * peer, so it's fine to be started via tor code. */
+  if (rust_hs_is_valid_conn(conn)) {
+    return event_active_write(conn);
+  }
+
   if (conn->linked) {
     conn->writing_to_linked_conn = 1;
     if (conn->linked_conn &&
diff '--color=auto' -ruN new-tor/src/core/mainloop/mainloop.h tor-tor-0.4.6.8/src/core/mainloop/mainloop.h
--- new-tor/src/core/mainloop/mainloop.h	2021-10-26 10:18:08.000000000 -0300
+++ tor-tor-0.4.6.8/src/core/mainloop/mainloop.h	2021-12-04 01:44:02.917000000 -0300
@@ -16,6 +16,8 @@
 void note_that_we_completed_a_circuit(void);
 void note_that_we_maybe_cant_complete_circuits(void);
 
+void rust_hs_connection_add(connection_t *conn);
+
 int connection_add_impl(connection_t *conn, int is_connecting);
 #define connection_add(conn) connection_add_impl((conn), 0)
 #define connection_add_connecting(conn) connection_add_impl((conn), 1)
diff '--color=auto' -ruN new-tor/src/core/or/connection_edge.c tor-tor-0.4.6.8/src/core/or/connection_edge.c
--- new-tor/src/core/or/connection_edge.c	2021-10-26 10:18:08.000000000 -0300
+++ tor-tor-0.4.6.8/src/core/or/connection_edge.c	2021-12-04 02:03:16.547000000 -0300
@@ -114,6 +114,8 @@
 #include "core/or/socks_request_st.h"
 #include "lib/evloop/compat_libevent.h"
 
+#include "feature/rust_hs/rust_hs.h"
+
 #ifdef HAVE_LINUX_TYPES_H
 #include <linux/types.h>
 #endif
@@ -4281,9 +4283,19 @@
     if (tor_addr_family(addr) == AF_INET6)
       conn->socket_family = AF_INET6;
 
-    log_debug(LD_EXIT, "about to try connecting");
-    result = connection_connect(conn, conn->address,
-                                addr, port, &socket_error);
+    if (rust_hs_is_valid_conn(conn)) {
+      conn->s = 1;  /** XXXX socket fd is never used, any value here */
+
+      /** Add the connection array */
+      rust_hs_connection_add(conn);
+
+      /** Call rust with connection information */
+      result = rust_hs_register_conn(conn->global_identifier, port);
+    } else {
+      log_debug(LD_EXIT, "about to try connecting");
+      result = connection_connect(conn, conn->address,
+                                  addr, port, &socket_error);
+    }
 #ifdef HAVE_SYS_UN_H
   } else {
     /*
diff '--color=auto' -ruN new-tor/src/feature/rust_hs/rust_hs.c tor-tor-0.4.6.8/src/feature/rust_hs/rust_hs.c
--- new-tor/src/feature/rust_hs/rust_hs.c	1969-12-31 21:00:00.000000000 -0300
+++ tor-tor-0.4.6.8/src/feature/rust_hs/rust_hs.c	2021-12-04 01:53:46.518000000 -0300
@@ -0,0 +1,18 @@
+#include "core/or/or.h"
+#include "core/or/connection_st.h"
+
+#include "feature/rust_hs/rust_hs.h"
+
+#include <event2/event.h>
+
+void event_active_read(connection_t *conn) {
+  event_active(conn->read_event, 0, 1);
+}
+
+void event_active_write(connection_t *conn) {
+  event_active(conn->write_event, 0, 1);
+}
+
+int rust_hs_is_valid_conn(connection_t *conn) {
+    return conn->type == 5 && rust_hs_conn_matches_port(conn->port);
+}
\ No newline at end of file
diff '--color=auto' -ruN new-tor/src/feature/rust_hs/rust_hs.h tor-tor-0.4.6.8/src/feature/rust_hs/rust_hs.h
--- new-tor/src/feature/rust_hs/rust_hs.h	1969-12-31 21:00:00.000000000 -0300
+++ tor-tor-0.4.6.8/src/feature/rust_hs/rust_hs.h	2021-12-04 02:05:05.487000000 -0300
@@ -0,0 +1,28 @@
+#ifndef RUST_HS_H
+#define RUST_HS_H
+
+/** Checks whether or not the given connection is a rust 
+ * hiddden service exit connection */
+int rust_hs_is_valid_conn(connection_t *conn);
+
+/** Retrieve the buffer to write into exit connection. */
+buf_t * rust_hs_read_buf(uint64_t global_identifier);
+/** Send buffer read by exit the connection. */
+void rust_hs_write_buf(uint64_t global_identifier, char *buf, size_t buf_len);
+
+/** Register a new connection.
+ * Returns:
+ *  -1 when failed to register.
+ *  0 when connection is new.
+ *  1 when connection is already opened. 
+*/
+int rust_hs_register_conn(uint64_t global_identifier, uint16_t port);
+/** Checks whether or not the hs listens to given port. */
+int rust_hs_conn_matches_port(uint16_t port);
+
+/** Manually call write event once */
+void event_active_write(connection_t *conn);
+/** Manually call read event once */
+void event_active_read(connection_t *conn);
+
+#endif /* !defined(RUST_HS_H) */
\ No newline at end of file
